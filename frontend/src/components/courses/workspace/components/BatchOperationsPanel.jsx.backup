import React, { useState, useMemo } from 'react';

const BatchActionButton = ({ 
  icon, 
  label, 
  action, 
  onClick, 
  disabled = false, 
  variant = 'default',
  count = 0 
}) => (
  <button
    className={`batch-action-btn ${variant} ${disabled ? 'disabled' : ''}`}
    onClick={() => onClick(action)}
    disabled={disabled}
    title={`${label} (${count} items)`}
  >
    <span className="action-icon">{icon}</span>
    <span className="action-label">{label}</span>
    <span className="action-count">{count}</span>
  </button>
);

const BatchEditModal = ({ selectedItems, onSave, onCancel }) => {
  const [editForm, setEditForm] = useState({
    status: '',
    assignTutor: '',
    scheduleDate: '',
    duration: '',
    maxParticipants: '',
    description: ''
  });
  const [validationErrors, setValidationErrors] = useState([]);
  const [isValidating, setIsValidating] = useState(false);

  const isSingleEdit = selectedItems.length === 1;
  const isBulkEdit = selectedItems.length > 1;

  // Get common properties from selected items
  const commonTypes = [...new Set(selectedItems.map(item => item.type))];
  const canEditStatus = isSingleEdit && commonTypes.every(type => ['module', 'lesson', 'quiz', 'session'].includes(type));
  const canEditSchedule = isSingleEdit && commonTypes.every(type => ['session'].includes(type));
  const canAssignTutor = isSingleEdit && commonTypes.every(type => ['session'].includes(type));
  const canEditDuration = commonTypes.every(type => ['session'].includes(type));
  const canEditParticipants = commonTypes.every(type => ['session'].includes(type));
  const canEditDescription = isSingleEdit && commonTypes.every(type => ['session'].includes(type));

  const handleFormChange = (field, value) => {
    setEditForm(prev => ({ ...prev, [field]: value }));
    // Clear validation errors when user starts typing
    if (validationErrors.length > 0) {
      setValidationErrors([]);
    }
  };

  const validateChanges = async () => {
    const errors = [];
    
    if (isSingleEdit && canEditSchedule && editForm.scheduleDate) {
      // TODO: Check for scheduling conflicts
      // This would integrate with the availability checking system
    }

    if (editForm.duration && (parseInt(editForm.duration) < 15 || parseInt(editForm.duration) > 480)) {
      errors.push('Duration must be between 15 and 480 minutes');
    }

    if (editForm.maxParticipants && parseInt(editForm.maxParticipants) < 1) {
      errors.push('Maximum participants must be at least 1');
    }

    setValidationErrors(errors);
    return errors.length === 0;
  };

  const handleSave = async () => {
    setIsValidating(true);
    const isValid = await validateChanges();
    setIsValidating(false);

    if (!isValid) {
      return;
    }

    // Map frontend form fields to API field names
    const fieldMapping = {
      maxParticipants: 'maxStudents',
      assignTutor: 'tutorId',
      scheduleDate: 'scheduledDate',
      status: 'status',
      duration: 'duration',
      description: 'description'
    };

    const changes = Object.entries(editForm)
      .filter(([_, value]) => value !== '')
      .reduce((acc, [key, value]) => {
        // Map frontend field names to API field names
        const apiFieldName = fieldMapping[key] || key;
        return { ...acc, [apiFieldName]: value };
      }, {});
    
    onSave(changes);
  };

  return (
    <div className="modal-overlay">
      <div className="modal-content batch-edit-modal">
        <div className="modal-header">
          <h3>{isSingleEdit ? 'Edit Session' : `Bulk Edit ${selectedItems.length} Sessions`}</h3>
          <button onClick={onCancel} className="modal-close">×</button>
        </div>

        <div className="modal-body">
          {validationErrors.length > 0 && (
            <div className="validation-errors">
              <div className="error-header">⚠️ Please fix the following issues:</div>
              <ul>
                {validationErrors.map((error, index) => (
                  <li key={index}>{error}</li>
                ))}
              </ul>
            </div>
          )}

          <div className="batch-edit-form">
            {/* Single Edit: Show all fields */}
            {canEditStatus && (
              <div className="form-group">
                <label>Session Status</label>
                <select 
                  value={editForm.status} 
                  onChange={(e) => handleFormChange('status', e.target.value)}
                >
                  <option value="">Keep current</option>
                  <option value="scheduled">Scheduled</option>
                  <option value="active">Active</option>
                  <option value="completed">Completed</option>
                  <option value="cancelled">Cancelled</option>
                  <option value="rescheduled">Rescheduled</option>
                </select>
              </div>
            )}

            {canEditSchedule && (
              <div className="form-group">
                <label>Schedule Date & Time</label>
                <input 
                  type="datetime-local"
                  value={editForm.scheduleDate}
                  onChange={(e) => handleFormChange('scheduleDate', e.target.value)}
                />
                <small className="field-help">Leave empty to keep current schedule</small>
              </div>
            )}

            {canAssignTutor && (
              <div className="form-group">
                <label>Assign Tutor</label>
                <select 
                  value={editForm.assignTutor} 
                  onChange={(e) => handleFormChange('assignTutor', e.target.value)}
                >
                  <option value="">Keep current tutor</option>
                  {/* TODO: Load tutors dynamically */}
                  <option value="tutor1">John Smith</option>
                  <option value="tutor2">Jane Doe</option>
                </select>
              </div>
            )}

            {/* Both Single and Bulk Edit: Duration */}
            {canEditDuration && (
              <div className="form-group">
                <label>Duration (minutes)</label>
                <input 
                  type="number"
                  value={editForm.duration}
                  onChange={(e) => handleFormChange('duration', e.target.value)}
                  placeholder={isBulkEdit ? "Set duration for all sessions" : "60"}
                  min="15"
                  max="480"
                  step="15"
                />
                <small className="field-help">Between 15 and 480 minutes</small>
              </div>
            )}

            {/* Both Single and Bulk Edit: Max Participants */}
            {canEditParticipants && (
              <div className="form-group">
                <label>Maximum Participants</label>
                <input 
                  type="number"
                  value={editForm.maxParticipants}
                  onChange={(e) => handleFormChange('maxParticipants', e.target.value)}
                  placeholder={isBulkEdit ? "Set limit for all sessions" : "3"}
                  min="1"
                  max="30"
                />
                <small className="field-help">Minimum 1 participant</small>
              </div>
            )}

            {/* Single Edit Only: Description */}
            {canEditDescription && (
              <div className="form-group">
                <label>Session Description</label>
                <textarea 
                  value={editForm.description}
                  onChange={(e) => handleFormChange('description', e.target.value)}
                  placeholder="Update session description..."
                  rows="3"
                />
              </div>
            )}

            {isBulkEdit && (
              <div className="bulk-edit-notice">
                <div className="notice-icon">ℹ️</div>
                <div className="notice-text">
                  <strong>Bulk Edit Mode:</strong> Only duration and maximum participants can be edited when multiple sessions are selected. 
                  Select a single session to access all editing options.
                </div>
              </div>
            )}
          </div>

          <div className="selected-items-preview">
            <h4>Selected Items:</h4>
            <div className="items-list">
              {selectedItems.slice(0, 5).map(item => (
                <div key={item.key} className="item-preview">
                  <span className="item-type">{item.type}</span>
                  <span className="item-title">{item.title}</span>
                </div>
              ))}
              {selectedItems.length > 5 && (
                <div className="items-more">
                  +{selectedItems.length - 5} more items
                </div>
              )}
            </div>
          </div>
        </div>

        <div className="modal-footer">
          <button onClick={onCancel} className="btn btn-secondary">
            Cancel
          </button>
          <button 
            onClick={handleSave} 
            className="btn btn-primary"
            disabled={isValidating}
          >
            {isValidating ? 'Validating...' : isSingleEdit ? 'Save Changes' : 'Apply to All Sessions'}
          </button>
        </div>
      </div>
    </div>
  );
};

const BatchScheduleModal = ({ selectedItems, onSave, onCancel }) => {
  const [scheduleForm, setScheduleForm] = useState({
    pattern: 'weekly',
    startDate: '',
    endDate: '',
    frequency: 1,
    days: [],
    time: '',
    duration: 60,
    tutorAssignment: 'auto'
  });

  const handleSave = () => {
    onSave(scheduleForm);
  };

  return (
    <div className="modal-overlay">
      <div className="modal-content batch-schedule-modal">
        <div className="modal-header">
          <h3>Batch Schedule {selectedItems.length} Sessions</h3>
          <button onClick={onCancel} className="modal-close">×</button>
        </div>

        <div className="modal-body">
          <div className="schedule-form">
            <div className="form-group">
              <label>Pattern</label>
              <select 
                value={scheduleForm.pattern}
                onChange={(e) => setScheduleForm({...scheduleForm, pattern: e.target.value})}
              >
                <option value="daily">Daily</option>
                <option value="weekly">Weekly</option>
                <option value="biweekly">Bi-weekly</option>
                <option value="monthly">Monthly</option>
              </select>
            </div>

            <div className="form-row">
              <div className="form-group">
                <label>Start Date</label>
                <input 
                  type="date"
                  value={scheduleForm.startDate}
                  onChange={(e) => setScheduleForm({...scheduleForm, startDate: e.target.value})}
                />
              </div>
              <div className="form-group">
                <label>End Date</label>
                <input 
                  type="date"
                  value={scheduleForm.endDate}
                  onChange={(e) => setScheduleForm({...scheduleForm, endDate: e.target.value})}
                />
              </div>
            </div>

            <div className="form-group">
              <label>Days of Week</label>
              <div className="days-selector">
                {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day, index) => (
                  <button
                    key={day}
                    type="button"
                    className={`day-btn ${scheduleForm.days.includes(index) ? 'selected' : ''}`}
                    onClick={() => {
                      const newDays = scheduleForm.days.includes(index)
                        ? scheduleForm.days.filter(d => d !== index)
                        : [...scheduleForm.days, index];
                      setScheduleForm({...scheduleForm, days: newDays});
                    }}
                  >
                    {day}
                  </button>
                ))}
              </div>
            </div>

            <div className="form-row">
              <div className="form-group">
                <label>Time</label>
                <input 
                  type="time"
                  value={scheduleForm.time}
                  onChange={(e) => setScheduleForm({...scheduleForm, time: e.target.value})}
                />
              </div>
              <div className="form-group">
                <label>Duration (min)</label>
                <input 
                  type="number"
                  value={scheduleForm.duration}
                  onChange={(e) => setScheduleForm({...scheduleForm, duration: parseInt(e.target.value)})}
                />
              </div>
            </div>
          </div>
        </div>

        <div className="modal-footer">
          <button onClick={onCancel} className="btn btn-secondary">
            Cancel
          </button>
          <button onClick={handleSave} className="btn btn-primary">
            Schedule Sessions
          </button>
        </div>
      </div>
    </div>
  );
};

const BatchOperationsPanel = ({ selectedItems, onBatchOperation }) => {
  const [showEditModal, setShowEditModal] = useState(false);
  const [showScheduleModal, setShowScheduleModal] = useState(false);

  // Analyze selected items to determine available operations
  const operationsConfig = useMemo(() => {
    const types = [...new Set(selectedItems.map(item => item.type))];
    const count = selectedItems.length;

    return {
      edit: {
        available: count > 0,
        icon: '📝',
        label: count === 1 ? 'Edit' : 'Bulk Edit',
        variant: 'default'
      },
      duplicate: {
        available: count > 0,
        icon: '📋',
        label: 'Duplicate',
        variant: 'default'
      },
      schedule: {
        available: count > 0 && types.every(type => type === 'session'),
        icon: '🗓️',
        label: 'Schedule',
        variant: 'default'
      },
      assign_tutors: {
        available: count > 0 && types.every(type => type === 'session'),
        icon: '👥',
        label: 'Assign Tutors',
        variant: 'default'
      },
      publish: {
        available: count > 0 && types.every(type => ['module', 'lesson', 'quiz'].includes(type)),
        icon: '📤',
        label: 'Publish',
        variant: 'success'
      },
      archive: {
        available: count > 0,
        icon: '📦',
        label: 'Archive',
        variant: 'warning'
      },
      delete: {
        available: count > 0,
        icon: '🗑️',
        label: 'Delete',
        variant: 'danger'
      }
    };
  }, [selectedItems]);

  const handleOperation = async (operation) => {
    switch (operation) {
      case 'edit':
        setShowEditModal(true);
        break;
      case 'schedule':
        setShowScheduleModal(true);
        break;
      case 'duplicate':
      case 'assign_tutors':
      case 'publish':
      case 'archive':
      case 'delete':
        await onBatchOperation(operation, selectedItems);
        break;
      default:
        console.warn('Unknown batch operation:', operation);
    }
  };

  const handleEditSave = async (changes) => {
    await onBatchOperation('edit', selectedItems, changes);
    setShowEditModal(false);
  };

  const handleScheduleSave = async (scheduleConfig) => {
    await onBatchOperation('schedule', selectedItems, scheduleConfig);
    setShowScheduleModal(false);
  };

  if (selectedItems.length === 0) {
    return null;
  }

  return (
    <>
      <div className="batch-operations-panel">
        <div className="panel-header">
          <h3>Batch Operations</h3>
          <div className="selection-summary">
            {selectedItems.length} item{selectedItems.length !== 1 ? 's' : ''} selected
          </div>
        </div>

        <div className="panel-content">
          <div className="batch-actions-grid">
            {Object.entries(operationsConfig)
              .filter(([_, config]) => config.available)
              .map(([operation, config]) => (
                <BatchActionButton
                  key={operation}
                  icon={config.icon}
                  label={config.label}
                  action={operation}
                  onClick={handleOperation}
                  variant={config.variant}
                  count={selectedItems.length}
                />
              ))}
          </div>

          <div className="selected-items-summary">
            <h4>Selected Items:</h4>
            <div className="items-breakdown">
              {Object.entries(
                selectedItems.reduce((acc, item) => {
                  acc[item.type] = (acc[item.type] || 0) + 1;
                  return acc;
                }, {})
              ).map(([type, count]) => (
                <span key={type} className="type-count">
                  {count} {type}{count !== 1 ? 's' : ''}
                </span>
              ))}
            </div>
          </div>
        </div>
      </div>

      {/* Modals */}
      {showEditModal && (
        <BatchEditModal
          selectedItems={selectedItems}
          onSave={handleEditSave}
          onCancel={() => setShowEditModal(false)}
        />
      )}

      {showScheduleModal && (
        <BatchScheduleModal
          selectedItems={selectedItems}
          onSave={handleScheduleSave}
          onCancel={() => setShowScheduleModal(false)}
        />
      )}
    </>
  );
};

export default BatchOperationsPanel;